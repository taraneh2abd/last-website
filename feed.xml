<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://alshedivat.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://alshedivat.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-01-21T17:04:32+00:00</updated><id>https://alshedivat.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">My graduation film</title><link href="https://alshedivat.github.io/blog/2023/videos/" rel="alternate" type="text/html" title="My graduation film"/><published>2023-04-24T15:12:00+00:00</published><updated>2023-04-24T15:12:00+00:00</updated><id>https://alshedivat.github.io/blog/2023/videos</id><content type="html" xml:base="https://alshedivat.github.io/blog/2023/videos/"><![CDATA[<div class="row mt-3"> <div class="col-sm-12"> <p class="text-center mb-0"> </p> <figure> <video src="/assets/video/pexels-engin-akyurt-6069112-960x540-30fps.mp4" class="img-fluid rounded z-depth-1" width="auto" height="auto" autoplay="" controls=""/> </figure> </div> </div> <div class="caption"> </div>]]></content><author><name></name></author><category term="graduation"/><category term="Yooooo"/><summary type="html"><![CDATA[IUST graduation üí™]]></summary></entry><entry><title type="html">Euler‚Äôs totient function</title><link href="https://alshedivat.github.io/blog/2015/images/" rel="alternate" type="text/html" title="Euler‚Äôs totient function"/><published>2015-10-20T15:12:00+00:00</published><updated>2015-10-20T15:12:00+00:00</updated><id>https://alshedivat.github.io/blog/2015/images</id><content type="html" xml:base="https://alshedivat.github.io/blog/2015/images/"><![CDATA[<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh"># Euler's Totient Function</span>

Euler's Totient Function, denoted as <span class="se">\(</span> <span class="se">\p</span>hi(n) <span class="se">\)</span>, is a number theory function that counts the positive integers up to a given integer <span class="se">\(</span> n <span class="se">\)</span> that are relatively prime to <span class="se">\(</span> n <span class="se">\)</span>. In other words, <span class="se">\(</span> <span class="se">\p</span>hi(n) <span class="se">\)</span> is the count of numbers less than or equal to <span class="se">\(</span> n <span class="se">\)</span> that do not share any common factors (other than 1) with <span class="se">\(</span> n <span class="se">\)</span>.

The formula for Euler's Totient Function is given by:

<span class="se">\[</span>
<span class="se">\p</span>hi(n) = n <span class="se">\p</span>rod_{p|n} <span class="se">\l</span>eft(1 - <span class="se">\f</span>rac{1}{p}<span class="se">\r</span>ight)
<span class="se">\]</span>

where the product is taken over all distinct prime numbers <span class="se">\(</span> p <span class="se">\)</span> that divide <span class="se">\(</span> n <span class="se">\)</span>. This formula essentially calculates <span class="se">\(</span> <span class="se">\p</span>hi(n) <span class="se">\)</span> by considering the contributions of all prime factors of <span class="se">\(</span> n <span class="se">\)</span>.

Euler's Totient Function has various applications in number theory and cryptography, particularly in RSA encryption, where it plays a crucial role in determining the security of the algorithm.

<span class="gu">## Properties of Euler's Totient Function</span>
<span class="p">
1.</span> <span class="gs">**Multiplicativity Property**</span>: For coprime integers <span class="se">\(</span> m <span class="se">\)</span> and <span class="se">\(</span> n <span class="se">\)</span>, we have <span class="se">\(</span> <span class="se">\p</span>hi(mn) = <span class="se">\p</span>hi(m) <span class="se">\c</span>dot <span class="se">\p</span>hi(n) <span class="se">\)</span>.
<span class="p">2.</span> <span class="gs">**Prime Numbers**</span>: For a prime number <span class="se">\(</span> p <span class="se">\)</span>, <span class="se">\(</span> <span class="se">\p</span>hi(p) = p - 1 <span class="se">\)</span>.
<span class="p">3.</span> <span class="gs">**Product of Primes**</span>: For distinct primes <span class="se">\(</span> p <span class="se">\)</span> and <span class="se">\(</span> q <span class="se">\)</span>, <span class="se">\(</span> <span class="se">\p</span>hi(pq) = (p-1)(q-1) <span class="se">\)</span>.
<span class="p">4.</span> <span class="gs">**Euler's Theorem**</span>: For any integer <span class="se">\(</span> a <span class="se">\)</span> coprime to <span class="se">\(</span> n <span class="se">\)</span>, <span class="se">\(</span> a^{<span class="se">\p</span>hi(n)} <span class="se">\e</span>quiv 1 <span class="se">\m</span>od n <span class="se">\)</span>.

These properties make Euler's Totient Function a powerful tool in number theory with applications in various areas of mathematics and computer science.<span class="sb">


</span></code></pre></div></div>]]></content><author><name></name></author><category term="math"/><category term="Euler_totient"/><summary type="html"><![CDATA[mathematics]]></summary></entry><entry><title type="html">SPARSE TABLE</title><link href="https://alshedivat.github.io/blog/2015/code/" rel="alternate" type="text/html" title="SPARSE TABLE"/><published>2015-07-15T15:09:00+00:00</published><updated>2015-07-15T15:09:00+00:00</updated><id>https://alshedivat.github.io/blog/2015/code</id><content type="html" xml:base="https://alshedivat.github.io/blog/2015/code/"><![CDATA[<p>this is the SPARSE TABLE Algorithm that I have recently learned‚Äî&gt;</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C++ program to do range minimum query</span>
<span class="c1">// using sparse table</span>
<span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#define MAX 500
</span>
<span class="c1">// lookup[i][j] is going to store minimum</span>
<span class="c1">// value in arr[i..j]. Ideally lookup table</span>
<span class="c1">// size should not be fixed and should be</span>
<span class="c1">// determined using n Log n. It is kept</span>
<span class="c1">// constant to keep code simple.</span>
<span class="kt">int</span> <span class="n">lookup</span><span class="p">[</span><span class="n">MAX</span><span class="p">][</span><span class="n">MAX</span><span class="p">];</span>

<span class="c1">// Fills lookup array lookup[][] in bottom up manner.</span>
<span class="kt">void</span> <span class="nf">buildSparseTable</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// Initialize M for the intervals with length 1</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">lookup</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="c1">// Compute values from smaller to bigger intervals</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="c1">// Compute minimum value for all intervals with</span>
		<span class="c1">// size 2^j</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

			<span class="c1">// For arr[2][10], we compare arr[lookup[0][7]] </span>
			<span class="c1">// and arr[lookup[3][10]]</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lookup</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> 
						<span class="n">lookup</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
				<span class="n">lookup</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
			<span class="k">else</span>
				<span class="n">lookup</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> 
						<span class="n">lookup</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Returns minimum of arr[L..R]</span>
<span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">R</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// Find highest power of 2 that is smaller</span>
	<span class="c1">// than or equal to count of elements in given</span>
	<span class="c1">// range. For [2, 10], j = 3</span>
	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">log2</span><span class="p">(</span><span class="n">R</span> <span class="o">-</span> <span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="c1">// Compute minimum of last 2^j elements with first</span>
	<span class="c1">// 2^j elements in range.</span>
	<span class="c1">// For [2, 10], we compare arr[lookup[0][3]] and</span>
	<span class="c1">// arr[lookup[3][3]],</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lookup</span><span class="p">[</span><span class="n">L</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lookup</span><span class="p">[</span><span class="n">R</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">lookup</span><span class="p">[</span><span class="n">L</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>

	<span class="k">else</span>
		<span class="k">return</span> <span class="n">lookup</span><span class="p">[</span><span class="n">R</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// Driver program</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">18</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">buildSparseTable</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">query</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">query</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">query</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="err">\</span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">myString</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"input a string: "</span><span class="p">;</span>
    <span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">myString</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">myString</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

    <span class="kt">char</span> <span class="n">charArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span> <span class="o">*</span> <span class="p">[</span><span class="n">length</span><span class="p">];</span>

    <span class="n">charArray</span> <span class="o">=</span> <span class="n">myString</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">charArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>For displaying code in a list item, you have to be aware of the indentation, as stated in this <a href="https://stackoverflow.com/questions/34987908/embed-a-code-block-in-a-list-item-with-proper-indentation-in-kramdown/38090598#38090598">Stackoverflow answer</a>. You must indent your code by <strong>(3 * bullet_indent_level)</strong> spaces. This is because kramdown (the markdown engine used by Jekyll) indentation for the code block in lists is determined by the column number of the first non-space character after the list item marker. For example:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gu">## the example:</span>

Input:  arr[]   = {7, 2, 3, 0, 5, 10, 3, 12, 18};
        query[] = [0, 4], [4, 7], [7, 8]

Output: Minimum of [0, 4] is 0
        Minimum of [4, 7] is 3
        Minimum of [7, 8] is 12

<span class="gu">## the algorithm:</span>
<span class="p">
1.</span> For (2, 10), j = floor(Log2(10-2+1)) = 3
j = floor(Log(R-L+1))
<span class="p">
2.</span> If lookup<span class="p">[</span><span class="nv">2</span><span class="p">][</span><span class="ss">3</span><span class="p">]</span> &lt;=  lookup<span class="p">[</span><span class="nv">3</span><span class="p">][</span><span class="ss">3</span><span class="p">]</span>, 
<span class="p">3.</span> then RMQ(2, 10) = lookup<span class="p">[</span><span class="nv">2</span><span class="p">][</span><span class="ss">3</span><span class="p">]</span>
<span class="p">4.</span> If lookup<span class="p">[</span><span class="nv">L</span><span class="p">][</span><span class="ss">j</span><span class="p">]</span> &lt;= lookup<span class="p">[</span><span class="nv">R-(int)pow(2, j)+1</span><span class="p">][</span><span class="ss">j</span><span class="p">]</span>
   RMQ(L, R) = lookup<span class="p">[</span><span class="nv">L</span><span class="p">][</span><span class="ss">j</span><span class="p">]</span>
<span class="p">
5.</span> If lookup<span class="p">[</span><span class="nv">2</span><span class="p">][</span><span class="ss">3</span><span class="p">]</span> &gt;  arr<span class="p">[</span><span class="nv">lookup[3</span><span class="p">][</span><span class="ss">3</span><span class="p">]</span>, 
<span class="p">6.</span> then RMQ(2, 10) = lookup<span class="p">[</span><span class="nv">3</span><span class="p">][</span><span class="ss">3</span><span class="p">]</span>
Else 
   RMQ(L, R) = lookup<span class="p">[</span><span class="nv">R-(int)pow(2, j)+1</span><span class="p">][</span><span class="ss">j</span><span class="p">]</span>

</code></pre></div></div> <p>just a reminder</p> <ul> <li> <p>Don‚Äôt forget to define MAX as a little as you can</p> <p>cause you need to have 2D matrix. for example‚Äì&gt;</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>```
#define MAX 500
```
</code></pre></div> </div> </li> </ul>]]></content><author><name></name></author><category term="code"/><category term="algorithm"/><summary type="html"><![CDATA[code]]></summary></entry><entry><title type="html">the perfect tree</title><link href="https://alshedivat.github.io/blog/2015/math/" rel="alternate" type="text/html" title="the perfect tree"/><published>2015-05-15T21:01:00+00:00</published><updated>2015-05-15T21:01:00+00:00</updated><id>https://alshedivat.github.io/blog/2015/math</id><content type="html" xml:base="https://alshedivat.github.io/blog/2015/math/"><![CDATA[<p>look at the perfect tree with fractals‚Ä¶</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/Fractal_tree-480.webp 480w,/assets/img/Fractal_tree-800.webp 800w,/assets/img/Fractal_tree-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/Fractal_tree.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/7-480.webp 480w,/assets/img/7-800.webp 800w,/assets/img/7-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/7.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Fractals, a fascinating concept in mathematics, art, and nature, are intricate geometric patterns that repeat at different scales. The term ‚Äúfractal‚Äù was coined by mathematician Beno√Æt Mandelbrot in 1975, derived from the Latin word ‚Äúfractus,‚Äù meaning broken or fragmented.</p> <p>Fractals exhibit self-similarity, where each part resembles the whole, regardless of the level of magnification. This property distinguishes them from traditional geometric shapes and makes them a unique and captivating subject of study.</p>]]></content><author><name></name></author><category term="math"/><category term="fractals"/><summary type="html"><![CDATA[images]]></summary></entry></feed>